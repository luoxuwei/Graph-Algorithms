# 最短路径算法

**定义**

求在图中从一点到另一点间路径上所有边权值相加和最小的路径

**应用**

路径规划

**带权最短路径**

对于无权图，用BFS遍历，就能找到最短的路径，但一旦边上带了权重，就不一样了，有时候边数最少的路径不一定是所有权值相加和最小的路径。以坐飞机为例子，有时候
我们直飞的话票价是很贵的，途中转几次机的话这个票价反而是便宜的。我们以票价作为边上的权值的话，我们想找到最小费用，从某个城市飞到另外一个城市，相应的
的航班路线选择的话，很有可能，我们不应该选择直飞这种情况。这就是对于图来说，我们引入权值后所产生的问题。 

**Dijkstra算法**

1.不能处理负权边，实际上大量应用不一来负权边。

2.Dijkstra算法用一个dis数组保存从源点到每一个顶点的最短路径，初始时没开始遍历，都设置成正无穷，代表到达不了。

3.我们选定源点后对应的dis值就可以设为0，与它相连的顶点对应的路径的dis值就是对应边的权值。源点对应的点就已经确定结果了，那么与源点两连的顶点，的最短路径结果还没有确定。
对于这些与源点两连的顶点，其中dis值最小的顶点的结果也可以确定了，因为，这个顶点是我们当前看到的从源点到其他的顶点所对应的最短的那个路径，那些没被遍历的都是正无穷，而这个顶点
又是dis值最小的顶点。对于带权图，求他的最短路径和无权图的区别就是在于，带权图我们有可能绕一个道，先走其他的顶点，走其他的边再回到，这个顶点所得到
的权值和反而更小，但是现在对于这个dis最小的距离已经是从源点到其他顶点的距离中最小的距离了，**因为绕道也要从源点出发，经过这些与源点相连的路径**，可以想象，我们从其他的顶点绕道在回到这个顶点所得到的结果
一定比现在的还要大,  最后绕道这个顶点的路径权值和也要加上这里就应用到了，第一点，由于我们所处理的图没有负权边， 我们从其他的顶点绕道回到这个顶点一定产生新的耗费。一定比现在的要大。

4.可以在想象一下，如果不是最小的，就不能肯定这个值是从源点到这个顶点最小的权值了，就是因为我们现在还存在一个权值更小的路径，很有可能从那个距离更小的点绕道过来的路径的值更小。所以我们当前
求出来的，从源点到其他所有顶点的路径，对于不是最小长度的那些顶点，我们还不能确定当前的路径长度就是最短的路径长度，但是对于最短的路径，我们可以肯定现在求出来的距离就是从源点
到这顶点的最短路径长度。现在我们就确定了连个顶点的最短路径。

5.接着我们再来看一下，从新确定的这个点出发，到其他的顶点会不会比原先我们已知的从源点出发走其他的路径到其他的顶点那个结果更小了。我们从新确定的顶点出发，更新与它相连的顶点
的路径值，如果新的路径值更小就更新为这个更小的路径值。更新完之后，我们重复之前的过程，在新更新的值中的最小的那个点，就可以确认了。在一这个新确认的点开始，更新与它相连的顶点的路径值。

6.当所有的顶点的路径值都确认了之后，我们就得到了，从源点出发，到其他顶点对应的最短路径长度。

**算法总结**

1.找到当前没有访问的最短路节点
 
2.确认这个节点的最短路就是当前的大小

3.根据这个节点的最短路大小，更新其他节点的路径长度 dis[b] = min(dis[a] + ab, dis[b])


