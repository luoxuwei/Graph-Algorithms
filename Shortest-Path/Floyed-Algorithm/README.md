# Floyed算法

1.求出图中任意两点间的最短路

2.之所以要有一个高效的算法专门求图中所有顶点间的最短路。也是有一些应用，比如求图的直径，图的直径是指图中所有点对间最短路的最大值。

3.求图的直径的应用，比如一个交通系统中，直径就是一个点到另一个点最远的距离， 我们要改善交通系统就可以不断的减小图的直径，图的直径越小就
意味着我们的交通系统越便捷，我们在这交通系统中任意选两个城市，从一个城市到另一个城市都可以非常快的到达。

4.对于单源路径算法，我们只需要运行V次，对图中的每一个顶点都设成单源路径中的源。这样等于求解了所有点对的最短路径问题。

5.对dijkstra算法来说，求所有点对的最短路的复杂度是O(VElogE), 但图中不能包含负权边。

6.对Bellman-Ford算法，求所有点对的最短路的复杂度是O(VVE),可以包含负权边，但需要检测负权环。

7.Floyed O(VVV), Floyed算法原理和松弛操作非常像

**Floyed算法流程**

1.Floyed更新顶点间的最短路径的流程与松弛操作类似，松弛操作是当我们找到从b点绕道到a点的路径比从s点直接到a点更短就更新a点的最短路径值，
```java
if(dis[b] + ab < dis[a])
    dis[a] = dis[b] + ab
```
整体上Floyed原理和这个流程很像，区别只在于对Floyed原理来说，它考虑的是ab之间不一定是一条边，反正Floyed解决的是所有点对间的最短路问题，所以我们也可以
想成是当前我们也找到了一条从a到b之间的一条最短路，这个最短路径之间也可能经过了多个顶点，不一定是一条边，在这样的情况下，我们的这个不等式所表达的
含义依然是存在的区别就在于，用的ab代表的是一条边，实际此时ab表示的是当前我们已经找到了，从b到a之间的最短路径。那么Floyed算法的基本原理就是:
```java
if (dis[v][b] + dis[b][a] < dis[v][a])
    dis[v][a] = dis[v][b] + dis[b][a]
```
Floyed算法求解的是所有点对间的最短路问题，所以dis是一个二维数组，有两个维度，dis[i][j] 表示的就是当前找到的从点i到点j的最短距离。Floyed算法的基本原理和
松弛操作是一样的，只不过松弛操作是对一个边进行松弛操作，但是Floyed算法基本原理是基于我们当下已经计算出了两点间的最短路径，然后根据这些两点间的对短路径
来看，我们绕了一条道后能不能得到一个更短的路径。一旦得到了更短的路径，我们就可以更新。

2.我们该以什么样的顺序来完成更新操作，使最终使得dis数组中每一个dis[i][j] 求出来的就是从i到j之间的最短路径？初始的时候 如果 v-w是一条边的话，我们使
dis[v][w] = vw; dis[v][v]=0; 否则dis[v][w] = 正无穷。

3.之后的遍历是这样的:
```java
for(int t=0; t<V; t++)
    for(int v=0; v<V; v++)
        for(int w=0; w<W; w++)
           if(dis[v][t] + dis[t][w] < dis[v][w])
              dis[v][w] = dis[v][t] + dis[t][w]
```
if语句就是松弛操作的变种，只不过我们不是对某一条具体的边进行松弛操作， 里面的两重循环，就是在不停的计算dis[v][w]的值，也就是在不停的计算所有点对，从v到w之间的最短距离，
但是它外面套上了一层t的循环，t这一点其实就是我们在找最短路径的时候去看是否从v到w可以多绕一个弯，先进过t点能够得到一个更短的路径，不过对于这层循环
为什么最终我们能得到一个最短路径，这里的核心原因，是我们每轮循环其实求解的是所有点对之间只经过[0...t]从零到t这些点的最短路径，在初始的时候，我们只是
对vw之间有一条边这样的dis进行了赋值。然后我们就开始了循环，我们第一重循环，对t=0进行了考察看看vw之间的最短距离如果绕道进过0这个点会不会得到一个更短的距离。
这轮循环我们就获得了所有点对之间如果我们中间允许他们进过0这个顶点的话相应的最短距离时多少，然后继续当t=1时，相当于我们又考虑了一个点，1这个点我们进行下面的两层循环
，其实就是开始考虑，如果从任何两个vw之间我们还能让它进过1这个点的话对应的最短路径时多少。换句话说，其实我们就考虑了如果任意两点之间，如果中间，能经过
0，1这两点的话最短路径是多少，注意这里是能进过这两个点，不是非要经过这两点，有可能进过一个，也有可能都不经过，有可能绕一个弯过来的路径更加的远，以此类推
我们求解的是对于所欲的两点如果我们允许他们经过0到v-1这么多个点的最短距离，当t遍历到最后一个点时其实最终的这轮循环就是求解对于所有点对之间如果我允许
它插入任意的点，允许经过这个图中的所有的其他的点，看在这种情况下我们最终求解出来的所有点对间的最短路劲是多少。这就是Floyed算法的基本原理。

4.这三重循环，第一层循环就是我们要绕道的那个点，我们在第一层循环中每次多考虑让所有点对之间可以多经过一个点来看他们求得的最短路是什么，而下面的两层循环
才是我们遍历所有点对vw来尝试看dis[v][w]这个值能不能更新

5.Floyed算法检测负权环的原理是在经过三重循环之后对于Floyed算法来说就计算出了所有点对中间我还可以插入任意点相应的最短距离是谁，此时Floyed也计算出来了自己到自己
的最短距离是谁，自己到自己的距离对一个图来说，如果没有负权环的话一定是零，但是如果图中含有负权环的话就是绕一圈我们的权值总和为负值，也就是自己到自己的距离dis[v][v]是小于零的。
所以我们运行一遍Floyed算法之后我们只需要查找一下dis[v][v]这个二维数组的对角线看一遍所有dis[v][v]的值如果这样的值有小于零的值就说明我们这个图中含有负权环，依然是对于含有
负权环的图，我们求解最短路的值是没有意义的。
