# 哈密尔顿回路

**定义**

从一个点出发，沿着边行走，能找到一条回路，经过每个点恰好一次，之后再回到出发点，

**概况**

1.1859年，爱尔兰数学家哈密尔顿提出周游世界的游戏，找到每个国家都经过一次的路线。

2.到目前为止，这个问题即一个图是否为哈密尔顿图的判定问题，还没有解决。在数学上找不到充分必要条件。

**算法思路**

1.暴力求解，找出每一条路径，再一个一个去验证。
找出每一条路的做法就是生成所有顶点的全排列。全排列的一种标准的实现是使用回溯法，但在图中回溯
的时候没必要生成每一种排列，因为一些无效的路径能在回溯的过程中识别丢弃。因此在图中回溯相当于剪枝。

2.在进行图遍历时，一旦遇到与这个顶点相连的所有顶点都访问过，但图中还有未遍历的顶点，就表示这条路径是
无效的，这个时候需要退回去，但退回去的时候需要将这个顶点的validate值设为false，我们在验证其他路径的时候需要判断是否能到达这个顶点，
这是回溯法的关键，表示我们真正的回到了，遍历到当前顶点之前的状态。

3.我们只需要从一个顶点开始遍历就行了，很显然，我们是要找一条哈密尔顿回路，如果图中存在一条哈密尔顿回路的话，这条回路肯定会过这个顶点，我们从这个顶点
就一定能找到这条回路。

4.虽然，我们在图中回溯有剪枝的优化，但算法复杂度还是O(n!).

**算法优化**

1.在基础版本的实现中allvisited方法的判断需要遍历所有的顶点，我们可以避免这点，只需要知道当前已经访问了多少个节点，用一个数字代替allvisited扫描

2.把判断当前是否是回路的判断提前到遍历相连顶点之前，而不是在遍历两连顶点的时候。

3.状态压缩，就是讲visited数组用一个数代替，通过位操作，来判断某个顶点是否被遍历过

4.记忆化搜索，就是保存某个状态是否已经遍历过，在回溯算法中的状态就是visited数组 + V，能起作用关键是搜索过程中有重复的情况，所以具体效果还和具体内容有关，在回溯的算法里有优化的空间是因为，有回退的操作，这个操作会参数重复的状态。