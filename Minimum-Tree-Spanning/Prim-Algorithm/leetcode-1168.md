
# leetcode 1168 解题记录

在解决[leetcode 1168](https://leetcode-cn.com/problems/optimize-water-distribution-in-a-village)这道题时，遇到了困难，最开始的尝试没有解决，后来看了其他人的解题思路才想清楚其中的关键。
发现自己图论算法练习不够，求解思路生硬，幼稚，缺乏敏感度。这种生硬的感觉应该是所有初学者都会有的阶段吧，算法真是靠练。初学者，容易犯读死书死读书的错误，一开始总是习惯生搬硬套理论知识，而不是关注具体问题，
我在一开始，有一个初步印象，只要选择花费最小的房子打井其他的通过水管相连，剩下的就是求最小生成树了，认为是一个求解最小生成树后，就一个一个概念套了，先看图的连通性，求个连通分量，想道，可能有些点没有边，
但也是也要算进去，就求个出图的所有连通分量再每个单独求最小生成树。之后汇总。
都没想过该用哪个求最小生成树的算法，只看到是求最小生成树，哪个算法不都一样。更多的是在套概念，没有去想是要解决什么问题。
之后提交了几次都失败了，还总是不解，为什么我的算法都写对了还通不过。通过用失败的输入数据去算，才发觉到，没考虑到，有可能某些房子，自己打井的花费比通过水管相连更低，难道要切断图连接吗？
然后又陷入每个顶点切断又多少种可能，一个顶点切断后的影响怎么算，不仅仅是相连的，通过这个顶点相连的整个通陆都会被影响等， 一下就懵了。
不知道如何下手，就看了其他人的解题思路。主要是两种写法，但思路的底层都是一样的。对于某些顶点自己打井的花费比通过水管连接更小这种情况，
其实增加一个顶点，这个顶点与其他每个顶点相连，边的权值就是每个房子打井的费用。这样就可以在一个图求最小生成树了，不用考虑什么连通分量的个数，什么顶点切断的组合等。两种写法也是分别对应Kruskal和Prim两种求最小生成树的算法。
用Prim算法的话，就按照标准的套路去写就行了。用Kruskal 的写法可能更绕一点。先假设每个顶点都单独打井。这个时候的总花费就是每个顶点的权值和了。
然后对边用Kruskal算法去遍历，每次找出当前最小边，如果边的两侧不在同一个集合中，就比较边和两个端点的权值，如果这条边的权值比两个端点中权值最大的点的权值还大，就将这个点作废，如果小于最大的点大于较小的点，就把这个较小的点作废，改为边连。总花费减去这个点，加上这条边。

**算法迭代记录**

1.使用Kruskal算法实现时犯了一个错误，习惯性的在遍历过程中加了一个visitied验证，导致通不过
```java
for (WeightedEdge weightedEdge:weightedEdgeList) {

            Pair<Integer, Integer> a = uf.find(weightedEdge.V-1);
            Pair<Integer, Integer> b = uf.find(weightedEdge.W-1);
            if (visited[weightedEdge.V-1] && visited[weightedEdge.W-1])
                continue;
            visited[weightedEdge.V-1] = true;
            visited[weightedEdge.W-1] = true;
```

使用Kruskal算法时要求当前选择的边与已选择的边不够成回路，使用并查集做判断，只有这个限制条件。




