# Prim算法

1.对一个图来说，反正我们可以随便找一个切分，一旦我们找到了一个切分，我们至少知道了最小生成树的一条边。prim算法就从一个顶点开始，把图切分成1:V-1
这样的一个切分，这个一个顶点怎么选都可以，对于这样一个切分我们就能找到图上所有的横切边，在这些横切边中的最小边就一定属于最小生成树。

2.一旦我们选了一条边后，Prim算法就改变这个切分，把选择了的这条边的另一个顶点加入都那个之前切分的起始那一半。这个切分就变成2:V-2, 对于现在的这个切分，
它的所有横切边中最小的边一定属于最小生成树，我们选择了这条边后，又可以更新切分了。我们把新选择的边的另一个顶点加入到这个切分的另一半，切分变成3:V-3,
对于这个新的切分，我们又可以找到横切边，我们接着选择这些横切边中的最小边，再更新切分。到最后我们会把所有的顶点都遍历一遍，整个图再也找不到切分了，我们就找到了最小生成树。

3.在不断更新切分的过程中，每更新一次切分，之前切分的横切边中一些边就会变成非横切边，这个效果相当于，Kruskal算法的选择边的过程中排除那些能构成环的边。

**Prim算法实现**

1.理解了prim算法的过程后，对于实现这个算法的关键应该会有一个认知，那就是怎么表示一个切分，由于一个图是别切分成两个部分，我们可以用一个visited数组
表示，值为true的顶点是一个部分，值为false的是另一个部分。
```java
boolean[] visited = new boolean[G.V()];
visited[0] = true;
```

2.实现Prim算法的另一个部分是，迭代的找每一个切分中的最小横切边，找到最小生成树我们需要执行v-1次迭代，我们选择最小横切边，就需要找到所有横切边，
我们用简单的做法，就遍历每个顶点，的每条边，就能找到所有横切边了
```java
for (int v = 0; v < G.V(); v++)
    if(!visited[v]) {
        for(int w:G.adj(v)) {
            if (!visited[w])
                ......
        }
    }
```

3.Prim算法和Kruskal算法最终找到了边的顺序是不一样的，因为，Kruskal算法每次找的是全局最小的边，而Prim算法每次找到的当前切分的横切边中最小的边
不是全局最小的。

4.prim算法的时间复杂度是 O((V-1)*(V+E)),我们执行v-1次迭代，每次找最小的边是V+E,这个复杂度高于kruskal的O(ElogE).

**Prim算法优化**

1.Prim算法中，每轮寻找最小横切边都要把所有的边扫描一下，是消耗比较大的操作，但是，其实当我们纳入一个新的顶点时，我们要考虑的边只是多了一些边而已，
并且多的这些边一定是以新纳入的顶点为起始点对应的边，这样一来，我们只需要把新的这些边添加到某个集合中进行考虑就好了。我们没有必要再次扫描整个图中所有的边，
这样的想法，就提示了我们，其实我们可以用某一种数据结构来存取当前我们要考虑的横切边。之后我们要做的就是在拓展这个切分的时候，把我们新要考虑的横切边加入到这个
数据结构就好了。

2.这个数据结构出了要保存这些横切边外，还要帮助我们快速的找到最短的横切边。因此，很显然优先队列是一个很好的选择。

3.在之前的分析中，我们知道，在每次更新切分时，一些之前的横切边变得不是横切边了。也就是优先队列中存储的所有的边不一定都是横切边，我们依旧是每次从
优先队列中取出一个边，只不过我们取出一个边后首先进行判断，判断下我们取出的这个边是不是横切边，是的话，我们就使用这个横切边，不是的话，我们直接丢弃就好了。

4.优化后的时间复杂度是O(ElogE),图中的每条边只会出一次优先队列，入一次优先队列，整个列队最大的容量就是所有的边都在队列里，优先队列里都有一个堆
，对于堆来说出堆入堆的操作是logE级别的，所以整体来看时间复杂度是O(ElogE)级别的。
