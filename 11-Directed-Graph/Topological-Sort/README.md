# 拓扑排序

在有向图中，我们需要找到一个顺序，我们图中遍历时，能做到在遍历每个顶点时都已经把这个顶点的前置顶点都已经遍历完毕，给出一个有向图，求出这样
一个顺序就叫做拓扑排序

**拓扑排序算法**

1.对于拓扑排序来讲，我们实际关心的是每一个顶点的入度，首先我们要找到入度为零的点，因为入度为零的点相当于没有任何前置的点，如果我们想象成
一门课程的话，这门课没有任何前置课程。我们可以直接学习它。

2.我们排好了一个顶点，相当于把这个顶点给删除了，我们已经学习完了这门课程，那这门课程在这个图中就不存在了。删除一个顶点的同时也意味着
要把和这个顶点相邻的边给删除掉。

3.删除了一个顶点和与它相邻的边，那同过这条边与它相连的顶点的入度也要更新了，那现在还没有被我们排序的顶点中入度为零的顶点就是我们下一个要
排序的顶点，我们排序完这个顶点后，与这个顶点相邻的边也就要删除了。删除之后继续更新现在图中的顶点的入度，再在图中找入度为零的点，如此
一个一个的排序下去，知道图中没有剩余的顶点了。最终的结果就是我们拓扑排序的结果。

4.由于删除边的操作很麻烦，在实现拓扑排序的过程中，我们并不需要真的把选中的点删除，我们只要假想这个点被删除了，之后对于从这个点能够到达的其他顶点的入度进行更新进行减一就好了

5.使用队列记录当前还未被处理的入度值为0的顶点，当我们删除一个顶点更新与它相邻的顶点的入度之后，就把新的入度值的顶点扔到这个队列，下面我们就
可以中这个列队中取出一个来排序，然后我们在删除这个顶点和更新与这个顶点相连的顶点的入度值。也就是每次我们更新入度值的时候就有顶点的入度值变为0
，我们就把入度值为0的顶点放入队列中留着下一次进行处理，也就是我们每次从队列中取出我们拓扑排序中下一个顶点。

6.实际我们拓扑排序的结果并不是唯一的。因为我们在每次更新顶点的入度值后，可能产生多个入度值为0的顶点。这个时候我们选择任何一个入度值为0的顶点排序都可以。
这样也没关系，只要不会出现，我们排序到某个顶点的时候它还有前置节点没被排序。排序只是保证了这样一个结果。

7.拓扑排序不一定有解，比如图是一个环，就找不到入度值为0的顶点。这种情况也很好理解，我们在完成一个任务a时，需要先完成任务b，完成任务b需要先完成任务
c，而要完成任务c又需要先完成任务a，这样其实是无法完成的。对于这种情况，虽然拓扑排序没有解，但是相当于，拓扑排序还有一个附加的效果，就是可以
帮助我们进行有向图的环检测，也就是对于一个有向图我们可以先进行一下拓扑排序，当我们发现拓扑排序进行到一定程度进行不下去了，不能使用拓扑排序
把图中所有的点排序好，此时就说明我们的有向图中是存在环的。这相当于我们有了另外一个在有向图中检测环的算法了，之前的是基于五向图环检测算法
进行修改得来的。

8.也就是只有DAG（有向无环图）才可以进行拓扑排序。如果图中存在环了，我们就不能进行拓扑排序。

**基于深度优先遍历的拓扑排序算法**

1.后序遍历是，对于一个节点，遍历完其所有相邻节点后，再遍历它自身。

2.对有向图进行深度优先后序遍历后的逆序就是拓扑排序的结果。对深度优先遍历后序的结果来说，每个节点它的后序节点一定出现在它的前面
那对这个结果求逆的话，最终的结果就是，对于所有的节点，它的前置节点先前的节点一定出现在它的前面。

3.但这个算法有一个坑，它不能像之前的那个算法那样帮我们检测环，对于有环有向图，我们依然可以对它进行深度优先的后序遍历。所以要用这个算法
必须保证，是DAG。

