# Bellman-Ford算法

1.Dijkstra 算法的缺陷是不能处理带负权边的图。如果存在负权边，在dijkstra算法里，当前距离最短的顶点，可以确认这个距离（权值和）就是这个顶点的最短距离，因为从其他边绕过来，
只会增加距离值，如果图中存在负权边就不一样了，更新顶点最短距离后就不能确定当前路径最短的顶点就是最短距离的，

2.如果存在负权边，假设到当前距离最短的顶点，有一条更短的路径，比这个距离还短，我们更新距离的策略其实和dijkstra算法一样，我们判断一下，如果我看到了dis[b]加上ab这条边的权值，
比当前的最短距离dis[a]还要小的话就更新dis[a] .用代码表示就是：
```java
if((dis[b] + ab) < dis[a] ) {
    dis[a] = dis[b] + ab
}
```

3.在dijkstra 算法中也是从当前确认的点出发，从源点到当前这个点的路径加上这个点的一个邻边的权值，这个加和是不是比这个领边到到的另外一点比我们已经求出来的
dis[]另外一点已知的这个路径还要小，如果还要小的话进行一下更新，那么这样的一个操作实际上是求最短路径的一个核心操作，这个操作本身是和我们操作的这条边的权值是
正还是负没有关系的。这个操作通常称作松弛操作 Relaxation 

4.这个松弛操作的原理非常简单，如果我们已经求出来了一些点的当前已知的最短路径，那么对于某条边，比如ba这条边，我们就可以看一下现在已知的到达b的最短路径
dis[b] 加上 ba这条边的权值是否比当前已知的(最小的)dis[a] 还要小，如果还要小的话，就相当于我们找到了一条，通过绕道可以得到的到达a的最短路径那么dis[a] 就可以更新。
有权图之所以求解最短路径比较麻烦，就是因为存在这种绕道之后得到的权值更小的情况，而这个松弛操作做到的事情就是在尝试绕一下道，看能不能找到一个更短的路径。

5.那么这个操作为什么叫做松弛操作，这是通过这个操作之后相比于我们直接从源点s到达这个a顶点的路径，我们更愿意选择先从s到b再从b到a，可以把，sb sa ba这些边想成是橡皮筋
其实sa这条边是更紧的，而sb ba 这俩条合在一起，从图上看，直观的看是更松的，而我们选择这条更松的路径是因为配合上权值之后，这个更加松的路径，它的权值和反而更低，所以这个
操作叫做松弛操作。

6.我们可以从ba方向松弛，也可以从ab方向做松弛操作。可以看出这个松弛操作是有方向性的， 在dijkstra算法中似乎没太管这个方向性，是因为在dijkstra算法中，我们一旦确定这个点是当前
已知的dis值最小的点，那么之后进行松弛操作一定是从a出发，看从a到达与它相邻的点，是否比从s直接走到这个点的距离还要短，所以dijkstra算法相当于帮我们
固定了方向，但是松弛操作是有方向的，我们可以从a到b的方向做松弛操作，也就可以从b到a的方向做松弛。当然这是针对无向图来说的，对于有向图，如果只能从a走到b。

7.这就是松弛操作，对于松弛操作来说它是有方向的，但是这个操作和边的权值的正负无关。 

8.Bellman-Ford算法也用一个数组来计算我们当前求出来的从源点到某一个顶点的最短路径，不过对于这个dis数组，它的定义是 dis[v]表示的是从源点s到v这个顶点经过的边数
不超过k的最短距离，这个dis[v]的定义，对从源点s到v这个顶点走过了多少边进行了一定的限制。ta不应该超过某个值k，那么对于这样的一个情况，松弛操作，dis[a]表示的是
从s到a经过的边数不超过k，dis[b]表示的是从s到b经过的边数不超过k，那么若果if (dis[a] + ab < dis[b]) 这个if成立的话，我们就对dis[b]进行更新，更新之后我们就找到了
从s到b经过的边数不操作k+1条相应的最短距离，换句话说我们每经过一次松弛操作，松弛操作就是尝试绕一条道看是不是得到的最短更加的短，那么绕一条道其实好就是多走了一条边
于是我们就从从s到v经过的边数不超过k的最短距离推导出了，从s出发经过的边数不超过k+1的最短距离。同理松弛操作也可以反着做。

9.Bellman-Ford算法就是利用了，我们进行一次松弛操作的结果，找到了一条多进过一条边的最短距离。这个流程就是；

1）初始时dis[s] = 0,其余dis值为正无穷，表示在初始的情况下，对源点来说我经过的边数不超过0也就一条边都不需要经过，那么相应的到源点的距离就是0，
对于其他的点来说，从源点s到其他的点进过的边数不超过0的话是到不了其他点的。也就是当下，我们找到的距离就是正无穷。

2）之后对所有的点都进行一次松弛操作。这次松弛操作就相当于我们初始知道的是从源点s到所有的边，经过的边数最多为0的最短路径，一次松弛操作后就求出了
从源点s到所有点经过的边数最多为1相应的最短路径。

3）再进行一次松弛操作就相当于从源点s到所有的点，经过的边数最多为2的最短路径。

4）依次类推整个过程我们重复v-1次松弛操作就求出了，到所有的点，经过的边数最多为V-1的最短路径，我们整个图中有v个点，从一点到另外一点的最短路径最多经过V-1条边，就是这条
路径把所有的点连接起来了。我们连接所有的点，只需要v-1条边。所以到最后如果我们对所有的边都进行v-1次松弛操作，我们求出了从源点s到所有的点，经过了边数最多为v-1的最短路，这个
结果本身也就是我们想要的答案了。

5）这就是Bellman-Ford算法的过程，Bellman-Ford算法就是对所有的边进行V-1轮的松弛操作，每一轮的松弛操作都对图中所有的边都进行一次松弛操作最终在dis中存储的就是Bellmen-Ford
算法所求出的最短路径。 由于整个松弛的过程不受负权边的影响，所以对于包含负权边的图也是成立的。

10.但是在这个过程中还是有一个小陷阱。当图中存在负权边时，当存在负权环的时候，没有最短路。在负权环中进行松弛操作时，每绕一圈就会减小一点，这样会一直不停的绕下去。
对于无向图，有负权边就相当于有负权环，比如ab是负权边，我们可以从a走到b，再从b走到a，又从a走到b，如此不停的转下去。

11.Dellmen-Ford算法中的对每一个顶点进行v-1轮松弛操作，v-1轮只是上界，实际上可以经过多少轮可以求出所有点的最短路，和实际遍历顺序有关。但是做v-1
轮松弛操作一定可以得到解。当然不能存在负权环。没有负权环，经过v-1次之后，最短路的值就不会变了，如果存在负权环，每绕一次最短路都会减小。经过v-1轮松弛操作
后，在进行一轮还是会减小，这个时候我们就可以确认当前的图存在负权环，求最短路是没有意义的。

